<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>IRIS Battleship</title>

	<link href="{{ url_for('static', filename='shared.css') }}" rel="stylesheet" type="text/css"/>
	<link href="{{ url_for('static', filename='examples.css') }}" rel="stylesheet" type="text/css"/>
	<script src="{{ url_for('static', filename='examples.js') }}"></script>
	<script src="{{ url_for('static', filename='easeljs-NEXT.js') }}"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

<script id="editable">
	var current_button;
	var canvas_mine, stage_mine;
	var canvas_enemy, stage_enemy;
	var game_id = "{{game_id}}";
	var player = "{{player}}";
	var mouseTarget;	// the display object currently under the mouse, or being dragged
	var dragStarted;	// indicates whether we are currently in a drag operation
	var offset;
	var update = true;
	var square_size = 50;
	var ships = [];
	var arrangement = []
	var ship_position = {}
	var max_index = 0;
	var canI = false;

	function init() {
		examples.showDistractor();
		// create stage and point it to the canvas:
		canvas_enemy = document.getElementById("canvas_enemy");
		stage_enemy = new createjs.Stage(canvas_enemy);

		// enable touch interactions if supported on the current device:
		createjs.Touch.enable(stage_enemy);

		// enabled mouse over / out events
		stage_enemy.enableMouseOver(10);
		stage_enemy.mouseMoveOutside = true; // keep tracking the mouse even when it leaves the canvas

		var container_enemy = new createjs.Container();
		container_enemy.name = "container_enemy";
		stage_enemy.addChild(container_enemy);
		// create the checkers
		for(var i=0;i<11;i++)
		{
			console.log(i);
			pos = i * square_size;

			if(i > 0)
			{
				var textv = new createjs.Text(i, "30px Arial", "#ff7700");
				stage_enemy.addChild(textv);
				textv.y = pos + 10;
				textv.x = 10;

				var texth = new createjs.Text(String.fromCharCode(64+i), "30px Arial", "#ff7700");
				stage_enemy.addChild(texth);
				texth.x = pos + 10;
				texth.y = 10;


				var linev = new createjs.Shape();
				stage_enemy.addChild(linev);
				linev.graphics.setStrokeStyle(1);
				linev.graphics.beginStroke("black");
				linev.graphics.moveTo(pos,0);
				linev.graphics.lineTo(pos,canvas_enemy.height);
				linev.graphics.endStroke();

				var lineh = new createjs.Shape();
				stage_enemy.addChild(lineh);
				lineh.graphics.setStrokeStyle(1);
				lineh.graphics.beginStroke("black");
				lineh.graphics.moveTo(0,pos);
				lineh.graphics.lineTo(canvas_enemy.width, pos);
				lineh.graphics.endStroke();

				//creating each button

				for(var j=0; j < 10;j++)
				{
					var btn = new createjs.Shape();
					var length = square_size;

					btn.graphics.beginFill("#FF0").drawRect(0, 0, square_size, square_size);
					btn.name = String.fromCharCode(65+j)+i;
					container_enemy.addChild(btn);

					btn.x = (j+1) * square_size;
					btn.y = (i) * square_size;
					btn.regX = btn.width / 2;
					btn.regY = btn.height / 2;

					btn.on("click", function (evt)
					{
						current_button = this;
						if(canI)
						{
						canI=false;
						 $.get("/xplode", { player:player,game_id:game_id,target:this.name}).done(function(data)
						 {
            				if(data=="hit")
            					color = "#FF0000";
            				else
            					color = "#CFCFCF";
							current_button.graphics.clear().beginFill(color).drawRect(0, 0, square_size, square_size).endFill();

							current_button.removeAllEventListeners();
							stage_enemy.update();

          				});
						}
						else
						{
							alert("wait your turn");
						}
					});

					stage_enemy.update();
				}
			}
		}
		stage_enemy.update();
		examples.hideDistractor();
		createjs.Ticker.addEventListener("tick", tick);
	}

	function stop() {
		createjs.Ticker.removeEventListener("tick", tick);
	}

	setInterval(canIPlay, 2000);

	function canIPlay()
	{
		url = "/caniplay/?game_id="+game_id+"&player="+player;
		$.get(url).done(function(data)
		{
			if(data=="1")
			{
				document.getElementById("warnings").innerHTML="Your turn!";
				canI=true;
			}
			else
			{
				document.getElementById("warnings").innerHTML="Waiting your enemy...";
				canI=false;
			}
		});
	}

	function handleImageLoad(event) {
		var image = event.target;
		var bitmap;
		var rect;
		var container = new createjs.Container();
		container.name = "cnt";
		// create the checkers
		for(var i=0;i<11;i++)
		{
			console.log(i);
			pos = i * square_size;

			if(i > 0)
			{
				var textv = new createjs.Text(i, "40px Arial", "#ff7700");
				stage.addChild(textv);
				textv.y = pos + 10;
				textv.x = 10;

				var texth = new createjs.Text(String.fromCharCode(64+i), "40px Arial", "#ff7700");
				stage.addChild(texth);
				texth.x = pos + 10;
				texth.y = 10;
			}

			stage.update();
			var linev = new createjs.Shape();
			stage.addChild(linev);
			linev.graphics.setStrokeStyle(1);
			linev.graphics.beginStroke("black");
			linev.graphics.moveTo(pos,0);
			linev.graphics.lineTo(pos,canvas_enemy.height);
			linev.graphics.endStroke();

			var lineh = new createjs.Shape();
			stage.addChild(lineh);
			lineh.graphics.setStrokeStyle(1);
			lineh.graphics.beginStroke("black");
			lineh.graphics.moveTo(0,pos);
			lineh.graphics.lineTo(canvas_enemy.width, pos);
			lineh.graphics.endStroke();
		}
		stage.update();

		stage.addChild(container);

		ships.push({name:"ship_0",size:5});
		ships.push({name:"ship_1",size:3});
		ships.push({name:"ship_2",size:3});
		ships.push({name:"ship_3",size:2});
		ships.push({name:"ship_4",size:2});

		// create and populate the screen with ships:
		for (var i = 0; i < ships.length; i++) {
			var ship = new createjs.Shape();
			var length = ships[i].size * square_size

			ship.graphics.setStrokeStyle(2).beginStroke("black").beginFill("#F00").drawRect(0, 0, length, square_size).beginFill("#FFF");
			ship.name = "ship_" + i;
			container.addChild(ship);

			ship.x = (i+1) * square_size;
			ship.y = (i+1) * square_size;
			ship.regX = ship.width / 2;
			ship.regY = ship.height / 2;



			ship.cursor = "pointer";

			// using "on" binds the listener to the scope of the currentTarget by default
			// in this case that means it executes in the scope of the button.
			ship.on("mousedown", function (evt) {
				this.parent.addChild(this);
				this.offset = {x: this.x - evt.stageX, y: this.y - evt.stageY};
			});

			// the pressmove event is dispatched when the mouse moves after a mousedown on the target until the mouse is released.
			ship.on("pressmove", function (evt) {
				x = evt.stageX + this.offset.x;
				y = evt.stageY + this.offset.y;

				_x = Math.round(x / square_size)
				_y = Math.round(y / square_size)

				this.x = _x * square_size;
				this.y = _y * square_size;

				console.log(this.name)
				// indicate that the stage should be updated on the next tick:
				update = true;
			});
			ship.on("dblclick", function (evt) {
				alert("to do: change orientation");
				// indicate that the stage should be updated on the next tick:
				update = true;
			});

		}

		examples.hideDistractor();
		createjs.Ticker.addEventListener("tick", tick);
	}

	function tick(event) {
		// this set makes it so the stage only re-renders when an event handler indicates a change has happened.
		if (update) {
			update = false; // only update once
			stage_enemy.update(event);
		}
	}
</script>

</head>

<body onload="init();">
<header>
	<h1>IRIS Battleship</h1>
	<p id="warnings">Waiting other player</p>
</header>

<div>
	<h3>Enemy Waters</h3>
	<canvas id="canvas_enemy" width="550" height="550"></canvas>
	<h3>Home Waters</h3>
	<canvas id="canvas_mine" width="550" height="550"></canvas>
</div>
</body>
</html>
